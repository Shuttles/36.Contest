# 二维前缀和

1. S(i, j)表示从martix(1, 1)到(i, j)的子矩阵和
2. 计算前缀和、根据前缀和计算区间和　都是基于容斥原理的思想



## 1.如何计算前缀和？

1. $S(x, y) = S(x-1, y) + S(x, y-1) - S(x-1,y-1) + martix(x, y) $

![img](https://wx3.sinaimg.cn/mw690/005LasY6ly1gpdvmlvy0ij30kv0aldhk.jpg)





## 2.如何计算区间和(子矩阵和)？

子矩阵左上角坐标为(x1, y1)，右下角坐标为(x2, y2)

1. 子矩阵和 = $S(x_2, y_2) - S(x_1-1, y_2) - S(x_2, y_1-1) + S(x_1-1, y_1-1)$

![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1gpdvmp8vzkj30lr0azdhp.jpg)



# 做题技巧

1. 如果空间不够，可以考虑直接用原数组的空间当做S！

2. 所有的坐标都是>=1的！！

   如果是二维的，那就x+1、y+1！





# 优化



K倍区间(acwing 1230)

1. 朴素做法：先枚举右端点，再枚举左端点　时间复杂度$O(n^2)$

2. 想优化掉内层循环，有一个办法，用空间换时间。

3. 仔细想想，内层循环在做什么？

   是在找下标在　$0 $ 至 $(r-1)$　范围内有几个s[]，它%k的余数和s[r]相同！

4. 于是，可以用一个数组cnt[i]，来存 %k之后余数为i的s[]的数量，这样内层循环就省去了，直接索引cnt[]即可！

   并且，cnt[]是可以一边遍历一边维护的！

5. 这种优化方法和最长上升子序列的优化方法很像，都是==空间换时间==

